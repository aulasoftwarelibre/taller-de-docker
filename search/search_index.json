{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Taller de docker","text":"<p>Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba.</p> <p>Info</p> <p>Se recomienda acudir al evento con tu propio port\u00e1til y con una distribuci\u00f3n GNU/Linux compatible con Docker: Ubuntu, Debian, Fedora o CentOS. Si no dispones de ordenador propio notif\u00edcalo a los organizaci\u00f3n en la web de la actividad.</p> <p>Warning</p> <p>Para evitar demoras innecesarias en el inicio de la actividad es necesario traer ya de casa Docker instalado. Para ello lee el cap\u00edtulo de Instalaci\u00f3n.</p>"},{"location":"containers/","title":"Contenedores","text":"<p>Los contenedores son instancias de las im\u00e1genes que hemos creado o hemos descargado que se ejecutan de forma aislada.</p>"},{"location":"containers/#listado","title":"Listado","text":"<p>La orden para ver el listado de contenedores del sistema es <code>docker container ls</code> o la forma abreviada <code>docker ps</code>. Si lo ejecutamos nos dar\u00e1 un listado vac\u00edo porque no hay ning\u00fan contenedor activo.</p> <p>Probemos con el par\u00e1metro <code>--all</code> o <code>-a</code>.</p> <pre><code>$ docker container ls -a\nCONTAINER ID  IMAGE        COMMAND     CREATED         STATUS      PORTS  NAMES\n4bd76e08b07f  wordpress    \"docker-\u2026\"  11 minutes ago  Exited (0)         peaceful_murdock\n69a3c34c224d  hello-world  \"/hello\"    18 minutes ago  Exited (0)         blissful_goldwasser\n</code></pre> <p>Estos contenedores est\u00e1n parados y se pueden volver a ejecutar, con el mismo estado que tuviera el sistema de archivos cuando se detuvieron.</p>"},{"location":"containers/#ejecutar-comandos-dentro-de-un-contenedor","title":"Ejecutar comandos dentro de un contenedor","text":"<p>Ya hemos usado <code>docker run</code> para crear e iniciar un contenedor. Tambi\u00e9n podemos usar este comando para ejecutar programas que est\u00e9n dentro del contenedor. Por ejemplo:</p> <pre><code>docker run --name ubuntu_bash --rm -i -t ubuntu bash\n</code></pre> <p>Info</p> <p>Las primeras versiones de Docker eran m\u00e1s limitadas, respecto a la creaci\u00f3n de objetos. As\u00ed que sali\u00f3 con comandos como <code>docker start</code>, <code>docker stop</code>, etc. relacionados con los contenedores. Cuando surgieron m\u00e1s objetos no hab\u00eda consistencia entre los comandos de otros objetos (como <code>docker volumes ls</code>) y los de los contenedores.</p> <p>As\u00ed que se ha creado una jerarqu\u00eda nueva de subcomandos bajo el comando <code>container</code> que son equivalentes y se mantienen por compatibilidad:</p> Antiguo Nuevo <code>docker run</code> <code>docker container run</code> <code>docker start</code> <code>docker container start</code> <code>docker stop</code> <code>docker container stop</code> <code>docker rm</code> <code>docker container rm</code> <code>docker inspect</code> <code>docker container inspect</code> <code>docker exec</code> <code>docker container exec</code> <p>No hay m\u00e1s diferencia entre ellos que el nombre.</p> <p>Pero esta forma de ejecutar cosas, crea un nuevo contenedor. Si queremos ejecutar un comando en un contenedor que ya est\u00e9 iniciado, debemos usar <code>docker container exec</code>.</p> <p>Ejecuta lo siguiente en otro terminal (no cierres el anterior).</p> <pre><code>docker exec -w /tmp ubuntu_bash touch my_file.sh\n</code></pre> <p>El par\u00e1metro <code>-w</code> indica el directorio de trabajo, despu\u00e9s indicamos el contenedor donde queremos ejecutar el comando (<code>ubuntu_bash</code>) y por \u00faltimo el comando a ejecutar (<code>touch my_file.sh</code>).</p> <p>Si en el primer terminal ejecutamos un listado del directorio tmp:</p> <pre><code># ls /tmp\nmy_file.sh\n</code></pre> <p>Vemos como podemos modificar un contenedor ya iniciado con <code>docker container exec</code>.</p> <p>Pulsa Ctrl+D  en el primer terminal para cerrar y borrar el contenedor.</p>"},{"location":"containers/#iniciar-un-contenedor","title":"Iniciar un contenedor","text":"<p>Con <code>docker container start</code> podemos iniciar un contenedor parado:</p> <p>Info</p> <p>Aqu\u00ed <code>peaceful_murdock</code> es el nombre del contenedor que nos sali\u00f3 en <code>docker container ls -a</code>. Tendr\u00e1s que cambiarlo por el nombre que te salga en tu equipo, dado que cuando no se asigna un nombre de forma espec\u00edfica, se asigna uno autom\u00e1tico.</p> <pre><code>$ docker container start peaceful_murdock \npeaceful_murdock\n$ docker container ls \nCONTAINER ID  IMAGE      COMMAND    CREATED         STATUS  PORTS                 NAMES\n4bd76e08b07f  wordpress  \"docker\u2026\"  14 minutes ago  Up      0.0.0.0:8080-&gt;80/tcp  peaceful_murdock\n</code></pre> <p>Veremos que la web de instalaci\u00f3n de WordPress est\u00e1 de nuevo disponible. Solo que ahora el contenedor se ejecuta en segundo plano y no lo podemos detener como antes.</p>"},{"location":"containers/#detener-un-contenedor","title":"Detener un contenedor","text":"<p>Con <code>docker container stop</code> podemos detener un contenedor iniciado, indicando su id o su nombre</p> <pre><code>$ docker container stop 4bd76e08b07f\n4bd76e08b07f\n</code></pre> <p>Tip</p> <p>Podemos hacer referencia a los contenedores por su ID o por su nombre.</p>"},{"location":"containers/#borrar-un-contenedor","title":"Borrar un contenedor","text":"<p>Un contenedor detenido ocupa espacio. Si hemos dejado de necesitar un contenedor podemos borrarlo con <code>docker container rm</code>. Igualmente hay que indicar id o nombre.</p> <pre><code>$ docker container rm 4bd76e08b07f\n4bd76e08b07f\n</code></pre> <p>Danger</p> <p>Hay que tener cuidado al borrar contenedores. Cuando un contenedor se borra se elimina cualquier informaci\u00f3n que contenga y no est\u00e9 almacenada en alg\u00fan lugar externo al propio contenedor.</p>"},{"location":"data/","title":"Persistiendo datos","text":"<p>Por defecto ya hemos indicado que un contenedor est\u00e1 aislado de todo. Hemos visto como podemos conectar el contenedor a un puerto de red para poder acceder a \u00e9l. Eso incluye al sistema de archivos que contiene. De tal manera que si se elimina el contenedor, se eliminan tambi\u00e9n sus archivos.</p> <p>Si queremos almacenar datos (una web, una base de datos, etc.) dentro de un contenedor necesitamos una manera de almacenarlos sin perderlos.</p> <p>Docker ofrece tres maneras:</p> <ul> <li>A trav\u00e9s de vol\u00famenes, que son objetos de Docker como las im\u00e1genes y los contenedores.</li> <li>Montando un directorio de la m\u00e1quina anfitri\u00f3n dentro del contenedor.</li> <li>Almacen\u00e1ndolo en la memoria del sistema (aunque tambi\u00e9n se perder\u00edan al reiniciar el servidor).</li> </ul> <p>Lo normal es usar vol\u00famenes, pero habr\u00e1 ocasiones en que es preferible montar directamente un directorio de nuestro espacio de trabajo. Por ejemplo, para guardar los datos de una base de datos usaremos vol\u00famenes, pero para guardar el c\u00f3digo de una aplicaci\u00f3n o de una p\u00e1gina web montaremos el directorio.</p> <p>La raz\u00f3n para esto \u00faltimo es que tanto nuestro entorno de desarrollo como el contenedor tengan acceso a los archivos del c\u00f3digo fuente. Los vol\u00famenes, al contrario que los directorios montados, no deben accederse desde la m\u00e1quina anfitri\u00f3n.</p>"},{"location":"data/#crear-un-volumen","title":"Crear un volumen","text":"<p>Como necesitamos crear una base de datos para nuestro blog con WordPress vamos a crear un volumen donde guardar la informaci\u00f3n:</p> <pre><code>$ docker volume create wordpress-db\nwordpress-db\n</code></pre>"},{"location":"data/#listar-volumenes","title":"Listar vol\u00famenes","text":"<p>Con <code>docker volume ls</code> podemos visualizar todos los volumenes disponibles.</p> <pre><code>$ docker volume ls\nDRIVER              VOLUME NAME\nlocal               wordpress-db\n</code></pre>"},{"location":"data/#visualizar-volumenes","title":"Visualizar vol\u00famenes","text":"<p>Los volumenes se crean en un directorio del sistema y no es recomendable acceder a \u00e9l, no al menos mientras haya un contenedor us\u00e1ndolo. En cualquier caso, si queremos ver los metadatos de un volumen podemos usar <code>docker volume inspect</code></p> <pre><code>$ docker volume inspect wordpress-db \n[\n    {\n        \"CreatedAt\": \"yyyy-mm-ddThh:ii:ss+Z\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/wordpress-db/_data\",\n        \"Name\": \"wordpress-db\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n</code></pre>"},{"location":"data/#borrar-volumenes","title":"Borrar volumenes","text":"<p>Como todos los objetos de Docker, los vol\u00famenes tambi\u00e9n pueden ser borrados, pero solo si no est\u00e1n en uso. Mucha precauci\u00f3n al borrar los vol\u00famenes, porque perder\u00edamos todos los datos que contenga.</p> <p>Para borrar un contenedor usaremos <code>docker volume rm</code> y el nombre del contenedor.</p>"},{"location":"docker-compose/","title":"Levantar un WordPress con Compose","text":"<p>El cliente de Docker es engorroso para crear contenedores, as\u00ed como para crear el resto de objetos y vincularlos entre s\u00ed.</p> <p>Para automatizar la creaci\u00f3n, inicio y parada de un contenedor o un conjunto de ellos, Docker proporciona un plugin llamada Compose.</p> <p>Para esta parte vamos a detener y borrar lo que hemos creado:</p> <p>Example</p> <p>Borra el trabajo actual:</p> <pre><code>docker container stop wordpress wordpress-db\ndocker container rm wordpress wordpress-db\ndocker volume rm wordpress-db\n</code></pre>"},{"location":"docker-compose/#docker-compose","title":"Docker Compose","text":"<p>Compose es una herramienta para definir y ejecutar aplicaciones multi-contenedor. Con un solo comando podremos crear e iniciar todos los servicios que necesitamos para nuestra aplicaci\u00f3n.</p> <p>Los casos de uso m\u00e1s habituales para docker compose son:</p> <ul> <li>Entornos de desarrollo</li> <li>Entornos de testeo autom\u00e1ticos (integraci\u00f3n cont\u00ednua)</li> <li>Despliegue en host individuales (no clusters)</li> </ul> <p>Compose tiene comandos para manejar todo el ciclo de vida de nuestra aplicaci\u00f3n:</p> <ul> <li>Iniciar, detener y rehacer servicios.</li> <li>Ver el estado de los servicios.</li> <li>Visualizar los logs.</li> <li>Ejecutar un comando en un servicio.</li> </ul>"},{"location":"docker-compose/#creacion-de-contenedores-automatizada","title":"Creaci\u00f3n de contenedores automatizada","text":"<p>En el mismo directorio donde est\u00e1bamos en el paso anterior (<code>~/Sites/wordpress</code>), vamos a crear un fichero llamado <code>docker compose.yaml</code> con el siguiente contenido:</p> docker-compose.yaml<pre><code>services:\n    db:\n        image: mariadb:10\n        volumes:\n            - data:/var/lib/mysql\n        environment:\n            - MYSQL_ROOT_PASSWORD=secret\n            - MYSQL_DATABASE=wordpress\n            - MYSQL_USER=manager\n            - MYSQL_PASSWORD=secret\n    web:\n        image: wordpress:6\n        depends_on:\n            - db\n        volumes:\n            - ./target:/var/www/html\n        environment:\n            - WORDPRESS_DB_USER=manager\n            - WORDPRESS_DB_PASSWORD=secret\n            - WORDPRESS_DB_HOST=db\n            - WORDPRESS_DB_NAME=wordpress\n        ports:\n            - 8080:80\n\nvolumes:\n    data:\n</code></pre> <p>Info</p> <p>YAML es un lenguaje de serializaci\u00f3n de datos dise\u00f1ado para ser le\u00eddo y escrito por personas. Se recomienda que sigas alg\u00fan tutorial para entender su formato: Aprende YAML en Y minutos.</p> <p>Los ficheros de Compose est\u00e1n divididos en tres secciones: services, volumes y networks; y deben indicar un n\u00famero de versi\u00f3n. Nos permite realizar practicamente lo mismo que podemos hacer con el cliente de docker, pero de forma autom\u00e1tica.</p> <p>Note</p> <p>En este taller no entramos en el apartado de networks.</p> <p>Con este fichero podemos hacer lo mismo que hemos hecho en el cap\u00edtulo anterior, pero con la ventaja de describir todos nuestros requisitos en un solo archivo.</p>"},{"location":"docker-compose/#iniciar-servicios","title":"Iniciar servicios","text":"<p>Vamos a ejecutar esta aplicaci\u00f3n y luego procederemos a explicarla:</p> <p>Example</p> <p>Arranca la aplicaci\u00f3n con Compose:</p> <pre><code>docker compose up -d\n</code></pre> <p>Cuando arrancamos la aplicaci\u00f3n, Compose nos informa de los servicios que ha ido levantando:</p> <pre><code>$ docker compose up -d\nCreating network \"wordpress_default\" with the default driver\nCreating volume \"wordpress_data\" with local driver\nCreating wordpress_db_1 ... \nCreating wordpress_db_1 ... done\nCreating wordpress_web_1 ... \nCreating wordpress_web_1 ... done\n</code></pre> <p>El par\u00e1metro <code>-d</code> es similar al que hemos visto en <code>docker run</code>: nos permite levantar los servicios en segundo plano.</p> <p>Veamos los contenedores activos:</p> <pre><code>$ docker container ls\nCONTAINER ID  IMAGE            COMMAND      CREATED         STATUS         PORTS                  NAMES\na07b5d4d3982  wordpress:6  \"docker.s\u2026\"  10 seconds ago  Up 8 seconds   0.0.0.0:8080-&gt;80/tcp   wordpress_web_1\nd9204884cec5  mariadb:10   \"docker.s\u2026\"  11 seconds ago  Up 10 seconds  3306/tcp               wordpress_db_1\n</code></pre> <p>Tambi\u00e9n podemos ver los contenedores con Compose:</p> <pre><code>$ docker compose ps\n    Name                    Command               State          Ports        \n-------------------------------------------------------------------------------\nwordpress_db_1    docker-entrypoint.sh mysqld      Up      3306/tcp            \nwordpress_web_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:8080-&gt;80/tcp\n</code></pre> <p>Lo que tenemos que tener en cuenta es lo siguiente:</p> <ul> <li><code>docker compose ps</code> solo muestra informaci\u00f3n de los servicios que se define en <code>docker compose.yaml</code>, mientras que <code>docker</code> muestra todos.</li> <li>Cuando creamos contenedores con <code>docker</code> sin indicar un nombre, por defecto asigna uno aleatorio; mientras que en Compose el prefijo es el nombre del directorio y el sufijo el nombre del servicio: wordpress_db_1. El n\u00famero indica el n\u00famero de instancia. Es posible levantar m\u00e1s de una instancia de un mismo servicio.</li> </ul> <p>Si accedemos a la direcci\u00f3n http://localhost:8080/, veremos de nuevo la instalaci\u00f3n de WordPress.</p>"},{"location":"docker-compose/#detener-servicios","title":"Detener servicios","text":"<p>Podemos detener servicios con</p> <pre><code>docker compose stop\n</code></pre>"},{"location":"docker-compose/#borrar-servicios","title":"Borrar servicios","text":"<p>Podemos borrar servicios con</p> <pre><code>docker compose down\n</code></pre> <p>Esto borra los contenedores, pero no los vol\u00famenes. As\u00ed que si hemos creado bien la aplicaci\u00f3n nuestros datos est\u00e1n a salvo.</p> <p>Si queremos borrar tambi\u00e9n los vol\u00famenes:</p> <pre><code>docker compose down -v\n</code></pre>"},{"location":"docker-compose/#estructura-de-la-configuracion","title":"Estructura de la configuraci\u00f3n","text":"<p>Veamos la configuraci\u00f3n por partes:</p> <pre><code>volumes:\n    data:\n</code></pre> <p>Ya hemos indicado que es importante guardar los datos vol\u00e1tiles de las aplicaciones en vol\u00famenes. En este caso hemos creado un volumen llamado <code>data</code>. Recordemos que Compose siempre a\u00f1ade como prefijo el nombre del directorio, con lo que el nombre real del volumen es <code>wordpress_data</code>. Podemos comprobarlo con el cliente de docker como hicimos en el cap\u00edtulo de vol\u00famenes:</p> <pre><code>$ docker volume ls\nDRIVER              VOLUME NAME\nlocal               wordpress_data\n</code></pre> <p>Nos saltamos la secci\u00f3n de redes (networks) y vamos a la secci\u00f3n de servicios, que son los contenedores que precisa o componen nuestra aplicaci\u00f3n.</p> <p>Primero la base de datos:</p> docker-compose.yaml<pre><code>services:\n    db:\n        image: mariadb:10\n        volumes:\n            - data:/var/lib/mysql\n        environment:\n            - MYSQL_ROOT_PASSWORD=secret\n            - MYSQL_DATABASE=wordpress\n            - MYSQL_USER=manager\n            - MYSQL_PASSWORD=secret\n</code></pre> <p>Despu\u00e9s de abrir la parte de servicios, el primer nivel indica el nombre del servicio <code>db</code>, que genera el contenedor <code>wordpress_db</code>. Lo que vemos a continuaci\u00f3n es lo mismo que hicimos en la secci\u00f3n anterior pero de forma parametrizada. Si recordamos, para levantar nuestra base de datos, indicamos la imagen (l\u00ednea 3), luego montamos los vol\u00famenes (l\u00ednea 4), y despu\u00e9s indicamos las variables de entorno que configuraban el contenedor (l\u00ednea 6).</p> <p>Es decir, lo anterior es equivalente, excepto por el nombre, a:</p> <pre><code>$ docker run -d --name wordpress-db \\\n        --mount source=wordpress-db,target=/var/lib/mysql \\\n        -e MYSQL_ROOT_PASSWORD=secret \\\n        -e MYSQL_DATABASE=wordpress \\\n        -e MYSQL_USER=manager \\\n        -e MYSQL_PASSWORD=secret mariadb:10\n</code></pre> <p>Y despu\u00e9s nuestro WordPress:</p> docker-compose.yaml<pre><code>services:\n    web:\n        image: wordpress:6\n        depends_on:\n            - db\n        volumes:\n            - ./target:/var/www/html\n        environment:\n            - WORDPRESS_DB_USER=manager\n            - WORDPRESS_DB_PASSWORD=secret\n            - WORDPRESS_DB_HOST=db\n        ports:\n            - 8080:80\n</code></pre> <p>En este caso la equivalencia es al comando:</p> <pre><code>$ docker run -d --name wordpress \\\n    --link wordpress-db:mysql \\\n    --mount type=bind,source=\"$(pwd)\"/target,target=/var/www/html \\\n    -e WORDPRESS_DB_USER=manager \\\n    -e WORDPRESS_DB_PASSWORD=secret \\\n    -p 8080:80 \\\n    wordpress:6\n</code></pre> <p>La equivalencia de los par\u00e1metros es la siguiente:</p> par\u00e1metro Docker par\u00e1metro Composer --link depends_on --mount volumes -e environment -p,--publish ports image <p>Note</p> <p>Si reiniciamos el ordenador, los contenedores estar\u00e1n detenidos (stop), podremos reiniciarlos con <code>docker start</code> o <code>docker compose start</code>. Este es el comportamiento predeterminado y el que nos interesa en un entorno de desarrollo.</p> <p>Sin embargo, en otros entornos, o para casos concretos, igual queremos que un contenedor tenga el mismo estado en el que estaba antes de reiniciar la m\u00e1quina (iniciado o parado).</p> <p>Para eso usaremos el par\u00e1metro <code>restart</code>. En el caso de la base de datos de nuestro ejemplo, la configuraci\u00f3n quedar\u00eda como:</p> docker-compose.yaml<pre><code>services:\n    db:\n        image: mariadb:10\n        restart: unless-stopped\n        volumes:\n            - data:/var/lib/mysql\n        environment:\n            - MYSQL_ROOT_PASSWORD=secret\n            - MYSQL_DATABASE=wordpress\n            - MYSQL_USER=manager\n            - MYSQL_PASSWORD=secret\n</code></pre> <p>El equivalente en la consola ser\u00eda:</p> <pre><code>$ docker run -d --name wordpress-db \\\n    --restart unless-stopped\n    --mount source=wordpress-db,target=/var/lib/mysql \\\n    -e MYSQL_ROOT_PASSWORD=secret \\\n    -e MYSQL_DATABASE=wordpress \\\n    -e MYSQL_USER=manager \\\n    -e MYSQL_PASSWORD=secret mariadb:10\n</code></pre> <p>Otros valores son: <code>no</code> (por defecto), <code>always</code> y <code>on-failure</code>.</p>"},{"location":"dockerfile/","title":"Crear im\u00e1genes propias","text":"<p>Ya hemos visto como usar im\u00e1genes de terceros para crear aplicaciones y servicios. Pero, \u00bfsi no hay ninguna imagen que tenga lo que queremos? \u00bfO si queremos hacer una imagen de nuestra aplicaci\u00f3n para distribuirla?</p> <p>Docker permite crear imagenes propias. Aunque podr\u00edamos hacerla partiendo de cero, es un esfuerzo que no tiene sentido. Existe ya im\u00e1genes base para crear las nuestras y es mucho m\u00e1s f\u00e1cil crear una imagen bas\u00e1ndose en otra que hacerlo todo nosotros.</p> <p>Podemos partir de una imagen base que parte de un lenguaje de programaci\u00f3n (python, php) o de alguna distribuci\u00f3n (ubuntu, debian).</p>"},{"location":"dockerfile/#mi-primer-dockerfile","title":"Mi primer Dockerfile","text":"<p>Los Dockerfile son los archivos que contienen las instrucciones que crean las imagenes. Deben estar guardados dentro de un build context, es decir, un directorio. Este directorio es el que contiene todos los archivos necesarios para construir nuestra imagen, de ah\u00ed lo de build context.</p> <p>Creamos nuestro build context</p> <pre><code>mkdir -p  ~/Sites/hello-world\ncd ~/Sites/hello-world\necho \"hello\" &gt; hello\n</code></pre> <p>Dentro de este directorio crearemos un archivo llamado Dockerfile con este contenido:</p> Dockerfile<pre><code>FROM busybox\nCOPY /hello /\nRUN cat /hello\n</code></pre> Directiva Explicaci\u00f3n FROM Indica la imagen base sobre la que se basa esta imagen COPY Copia un archivo del build context y lo guarda en la imagen RUN Ejecuta el comando indicado durante el proceso de creaci\u00f3n de imagen. <p>Ahora para crear nuestra imagen usaremos <code>docker build</code>.</p> <pre><code>docker build -t helloapp:v1 .\n</code></pre> <p>El par\u00e1metro <code>-t</code> nos permite etiquetar la imagen con un nombre y una versi\u00f3n. El <code>.</code> indica que el build context es el directorio actual.</p> <p>El resultado de ejecutar lo anterior ser\u00eda:</p> <pre><code>$ docker build -t helloapp:v1 .\nSending build context to Docker daemon  3.072kB\nStep 1/3 : FROM busybox\nlatest: Pulling from library/busybox\n8c5a7da1afbc: Pull complete \nDigest: sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd\nStatus: Downloaded newer image for busybox:latest\n ---&gt; e1ddd7948a1c\nStep 2/3 : COPY /hello /\n ---&gt; 8a092965dbc9\nStep 3/3 : RUN cat /hello\n ---&gt; Running in 83b5498790ca\nhello\nRemoving intermediate container 83b5498790ca\n ---&gt; f738f117d4b6\nSuccessfully built f738f117d4b6\nSuccessfully tagged helloapp:v1\n</code></pre> <p>Y podremos ver que una nueva imagen est\u00e1 instalada en nuestro equipo:</p> <pre><code>$ docker images\nREPOSITORY   TAG  IMAGE ID      CREATED         SIZE\nhelloapp     v1   f738f117d4b6  40 seconds ago  1.16MB\n</code></pre>"},{"location":"dockerfile/#creando-aplicaciones-en-contenedores","title":"Creando aplicaciones en contenedores","text":"<p>Vamos a crear un aplicaci\u00f3n en python y la vamos a guardarla en un contenedor. Comenzamos creando un nuevo build context:</p> <pre><code>mkdir -p  ~/Sites/friendlyhello\ncd ~/Sites/friendlyhello\n</code></pre> <p>El c\u00f3digo de la aplicaci\u00f3n es el siguiente, lo guardaremos en un archivo llamado <code>app.py</code>:</p> app.py<pre><code>from flask import Flask\nfrom redis import Redis, RedisError\nimport os\nimport socket\n\n# Connect to Redis\nredis = Redis(host=\"redis\", db=0, socket_connect_timeout=2, socket_timeout=2)\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    try:\n        visits = redis.incr(\"counter\")\n    except RedisError:\n        visits = \"&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;\"\n\n    html = \"&lt;h3&gt;Hello {name}!&lt;/h3&gt;\" \\\n            \"&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;\" \\\n            \"&lt;b&gt;Visits:&lt;/b&gt; {visits}\"\n    return html.format(name=os.getenv(\"NAME\", \"world\"), hostname=socket.gethostname(),  visits=visits)\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=80)\n</code></pre> <p>Nuestra aplicaci\u00f3n tiene una serie de dependencias (librer\u00edas de terceros) que guardaremos en el archivo requirements.txt:</p> <p>requirements.txt<pre><code>Flask\nRedis\n</code></pre> Y por \u00faltimo definimos nuestro Dockerfile:</p> Dockerfile<pre><code># Partimos de una base oficial de python\nFROM python:3-slim\n\n# El directorio de trabajo es desde donde se ejecuta el contenedor al iniciarse\nWORKDIR /app\n\n# Copiamos todos los archivos del build context al directorio /app del contenedor\nCOPY . /app\n\n# Ejecutamos pip para instalar las dependencias en el contenedor\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\n\n# Indicamos que este contenedor se comunica por el puerto 80/tcp\nEXPOSE 80\n\n# Declaramos una variable de entorno\nENV NAME World\n\n# Ejecuta nuestra aplicaci\u00f3n cuando se inicia el contenedor\nCMD [\"python\", \"app.py\"]\n</code></pre> <p>Para conocer todas las directivas visita la documentaci\u00f3n oficial de Dockerfile.</p> <p>En total debemos tener 3 archivos:</p> <pre><code>$ ls\napp.py  Dockerfile  requirements.txt\n</code></pre> <p>Ahora construimos la imagen de nuestra aplicaci\u00f3n:</p> <pre><code>docker build -t friendlyhello .\n</code></pre> <p>Y comprobamos que est\u00e1 creada:</p> <pre><code>$ docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nfriendlyhello       latest              88a822b3107c        56 seconds ago      132MB\n</code></pre>"},{"location":"dockerfile/#probar-nuestro-contenedor","title":"Probar nuestro contenedor","text":"<p>Vamos a arrancar nuestro contenedor y probar la aplicaci\u00f3n:</p> <pre><code>docker run --rm -p 4000:80 friendlyhello\n</code></pre> <p>Tip</p> <p>Normalmente los contenedores son de usar y tirar, sobre todo cuando hacemos pruebas. El par\u00e1metro <code>--rm</code> borra autom\u00e1ticamente un contenedor cuando se para. Recordemos que los datos vol\u00e1tiles siempre se deben guardar en vol\u00famenes.</p> <p>Lo que arranca la aplicaci\u00f3n Flask:</p> <pre><code>$ docker run --rm -p 4000:80 friendlyhello\n * Serving Flask app \"app\" (lazy loading)\n * Environment: production\n   WARNING: Do not use the development server in a production environment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)\n</code></pre> <p>Comprobamos en el puerto 4000 si efectivamente est\u00e1 iniciada o no: http://localhost:4000.</p> <p>Obtendremos un mensaje como este:</p> <pre><code>Hello World!\n\nHostname: 0367b056e66e\nVisits: cannot connect to Redis, counter disabled\n</code></pre> <p>Ya tenemos una imagen lista para ser usada. Pulsamos Ctrl+C para interrumpir y borrar nuestro contenedor.</p>"},{"location":"dockerfile/#creando-la-aplicacion","title":"Creando la aplicaci\u00f3n","text":"<p>En este caso nuestro contenedor no funciona por s\u00ed mismo. Es muy habitual que dependamos de servicios para poder iniciar la aplicaci\u00f3n, habitualmente bases de datos. En este caso necesitamos una base de datos Redis que no tenemos.</p> <p>Como vimos en el apartado anterior, vamos a aprovechar las caracter\u00edsticas de Compose para levantar nuestra aplicaci\u00f3n.</p> <p>Vamos a crear el siguiente archivo docker-compose.yaml:</p> docker-compose.yaml<pre><code>services:\n    web:\n        build: .\n        ports:\n            - \"4000:80\"\n    redis:\n        image: redis\n        ports:\n            - \"6379:6379\"\n        volumes:\n            - \"./data:/data\"\n        command: redis-server --appendonly yes\n</code></pre> <p>La principal diferencia con respecto al cap\u00edtulo anterior, es que en un servicio podemos indicar una imagen (par\u00e1metro <code>imagen</code>) o un build context (par\u00e1metro <code>build</code>). </p> <p>Esta es una manera de integrar las dos herramientas que nos proporciona Docker: la creaci\u00f3n de im\u00e1genes y la composici\u00f3n de aplicaciones con servicios.</p>"},{"location":"dockerfile/#balanceo-de-carga","title":"Balanceo de carga","text":"<p>Vamos a modificar nuestro docker-compose.yaml:</p> docker-compose.yaml<pre><code>services:\n    web:\n        build: .\n        labels:\n        - \"traefik.enable=true\"\n        - \"traefik.http.routers.web.rule=Host(`localhost`)\"\n        - \"traefik.http.routers.web.entrypoints=web\"\n        - \"traefik.http.services.web.loadbalancer.server.port=80\"\n    redis:\n        image: redis\n        volumes:\n            - \"./data:/data\"\n        command: redis-server --appendonly yes\n        labels:\n        - \"traefik.enable=false\"\n    traefik:\n        image: traefik:v2.3\n        command:\n        - \"--log.level=DEBUG\"\n        - \"--api.insecure=true\"\n        - \"--providers.docker=true\"\n        - \"--providers.docker.exposedByDefault=false\"\n        - \"--entrypoints.web.address=:4000\"\n        ports:\n        - \"4000:4000\" # Exponer Traefik en el puerto 4000 de localhost\n        - \"8080:8080\" # Dashboard de Traefik\n        volumes:\n        - \"/var/run/docker.sock:/var/run/docker.sock\"\n        labels:\n        - \"traefik.enable=true\"\n</code></pre> <p>En este caso, el servicio web no va a tener acceso al exterior (hemos eliminado el par\u00e1metro <code>ports</code>). En su lugar hemos a\u00f1adido un balanceador de carga (el servicio  <code>traefik</code>).</p> <p>Vamos a arrancar esta nueva aplicaci\u00f3n, pero esta vez a\u00f1adiendo varios servicios web:</p> <pre><code>docker compose up -d --scale web=5\n</code></pre> <p>Esperamos a que terminen de iniciar los servicios:</p> <pre><code>$ docker compose up -d --scale web=5\nCreating network \"friendlyhello_default\" with the default driver\nCreating friendlyhello_redis_1 ... done\nCreating friendlyhello_web_1   ... done\nCreating friendlyhello_web_2   ... done\nCreating friendlyhello_web_3   ... done\nCreating friendlyhello_web_4   ... done\nCreating friendlyhello_web_5   ... done\nCreating friendlyhello_traefik_1    ... done\n</code></pre> <p>Podemos comprobar como del servicio web nos ha iniciado 5 instancias, cada uno con su sufijo num\u00e9rico correspondiente. Si usamos <code>docker ps</code> para ver los contenedores disponibles tendremos:</p> <pre><code>$ docker ps\nCONTAINER ID  IMAGE                [...]   PORTS                                    NAMES\n77acae1d0567  traefik              [...]   443/tcp, 1936/tcp, 0.0.0.0:4000-&gt;80/tcp  friendlyhello_traefik_1\n5f12fb8b80c8  friendlyhello_web    [...]   80/tcp                                   friendlyhello_web_5\nfb0024591665  friendlyhello_web    [...]   80/tcp                                   friendlyhello_web_2\na20d20bdd129  friendlyhello_web    [...]   80/tcp                                   friendlyhello_web_4\n53d7db212df8  friendlyhello_web    [...]   80/tcp                                   friendlyhello_web_3\n41218dbbb882  friendlyhello_web    [...]   80/tcp                                   friendlyhello_web_1\n06f5bf6ed070  redis                [...]   6379/tcp                                 friendlyhello_redis_1\n</code></pre> <p>Vamos a fijarnos en el <code>CONTAINER ID</code> y vamos a volver a abrir nuestra aplicaci\u00f3n: http://localhost:4000.</p> <p>Si en esta ocasi\u00f3n vamos recargando la p\u00e1gina, veremos como cambian los hostnames, que a su vez coinciden con los identificadores de los contenedores anteriores.</p> <p>Info</p> <p>Esta no es la manera adecuada de hacer balanceo de carga, puesto que todos los contenedores est\u00e1n en la misma m\u00e1quina, lo cual no tiene sentido. Solo es una demostraci\u00f3n. Para hacer balanceo de carga real necesitar\u00edamos tener o emular un clustes de m\u00e1quinas y crear un enjambre (swarm).</p>"},{"location":"dockerfile/#compartir-imagenes","title":"Compartir im\u00e1genes","text":"<p>Si tenemos una imagen que queramos compartir, necesitamos usar un registro. Existe incluso una imagen que nos permite crear uno propio, pero vamos a usar el repositorio p\u00fablico de Docker.</p> <p>Los pasos son:</p> <ol> <li>Crear una cuenta de usuario en el repositorio oficial de Docker.</li> <li>Pulsar sobre el bot\u00f3n \"Create Repository +\".</li> <li> <p>En el formulario hay que rellenar solo un dato obligatoriamente: el nombre. Usaremos el de la imagen: friendlyhello.</p> <p>Nuestro nombre de usuario es el namespace y es obligatorio que tenga uno. Si estuvieramos en alguna organizaci\u00f3n podr\u00edamos elegir entre varios. El resto de campos lo dejamos como est\u00e1 por el momento. La cuenta gratuita solo deja tener un repositorio privado, asi que no lo malgastaremos aqu\u00ed.</p> </li> <li> <p>Ahora tenemos que conectar nuestro cliente de Docker con nuestra cuenta en el Hub. Usamos el comando <code>docker login</code>.</p> <pre><code>$\u00a0docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: username\nPassword: ********\nWARNING! Your password will be stored unencrypted in /home/sergio/.docker/config.json.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\n</code></pre> <p>Danger</p> <p>Las claves se guardan sin cifrar. Hay que configurar un almacen de claves o recordar hacer <code>docker logout</code> para borrarla.</p> <p>Visita la web de referencia para saber como crear un almacen.</p> </li> <li> <p>Para que las im\u00e1genes se puedan guardar, tenemos que etiquetarla con el mismo nombre que tengamos en nuestro repositorio m\u00e1s el namespace. Si nuestra cuenta es 'username' y el repositorio es 'friendlyhello', debemos crear la imagen con la etiqueta 'username/friendlyhello'.</p> <pre><code>$ docker build -t username/friendlyhello .\n</code></pre> <p>Tip</p> <p>Por defecto ya hemos dicho que la etiqueta si no se indica es latest. Podemos indicar m\u00e1s de una etiqueta para indicar versiones:</p> <pre><code>$ docker build -t username/friendlyhello -t username/friendlyhello:0.1.0 .\n</code></pre> <p>En la pr\u00f3xima que hagamos le subimos la versi\u00f3n en la etiqueta:</p> <pre><code>$ docker build -t username/friendlyhello -t username/friendlyhello:0.2.0 .\n</code></pre> <p>De esta manera nuestra imagen aparecer\u00e1 con tres etiquetas: latest y 0.2.0 que ser\u00e1n la misma en realidad, y 0.1.0.</p> </li> <li> <p>Ahora ya podemos enviar nuestra imagen:</p> <pre><code>$ docker push username/friendlyhello\n</code></pre> </li> </ol>"},{"location":"dockerfile/#ejercicios","title":"Ejercicios","text":"<ol> <li>Cambia el docker-compose.yaml para usar tu imagen en vez de hacer build.</li> <li>Cambia el docker-compose.yaml para usar la imagen de alg\u00fan compa\u00f1ero. </li> </ol>"},{"location":"images/","title":"Im\u00e1genes","text":"<p>Las im\u00e1genes son la base de Docker. Nuestros contenedores se iniciar\u00e1n a partir de ellas. Como se indic\u00f3 en la introducci\u00f3n, es una plantilla de solo lectura, que se crea incorporando los requisitos necesarios para cumplir el objetivo para el cual fue creada.</p> <p>Por ejemplo, si estamos creando un proyecto con PHP, incorporar\u00e1 el int\u00e9rprete del lenguaje de PHP. Si es una p\u00e1gina web, incorporar\u00e1 el servidor web (apache, nginx, etc.).</p>"},{"location":"images/#buscar-imagenes","title":"Buscar im\u00e1genes","text":"<p>Crear una imagen desde cero supone un esfuerzo demasiado grande, as\u00ed que lo normal es partir o usar una ya creada.</p> <p>Para ellos buscaremos en los registros, el lugar donde se almacenan. Hay un registro oficial (https://hub.docker.com), pero nada impide a otras organizaciones, o a nosotros mismo, tener un registro propio. Estos registros pueden ser privados o p\u00fablicos.</p> <p>Imaginemos que queremos crear una web con WordPress. Si buscamos en el registro encontraremos una imagen llamada wordpress, con la etiqueta oficial. La recomendaci\u00f3n es que siempre busquemos im\u00e1genes oficiales, est\u00e1n mantenidas y bien documentadas.</p> <p>En la p\u00e1gina encontraremos las diferentes opciones que tiene esta imagen para configurarla, aunque las veremos con m\u00e1s detalle m\u00e1s adelante.</p> <p>Por ahora iniciemos la imagen como se indica:</p> <p>Example</p> <p>Iniciar una imagen de WordPress:</p> <pre><code>docker run -p 8080:80 wordpress:6\n</code></pre> <p>Y comprobaremos como se inicia el contenedor:</p> <pre><code>$ docker run -p 8080:80 wordpress\nUnable to find image 'wordpress:latest' locally\nlatest: Pulling from library/wordpress\n802b00ed6f79: Pull complete \n[...]\nd3da911b920f: Pull complete \n94c7e0af5b20: Pull complete \ne1f39ac90dec: Pull complete \nDigest: sha256:7121cdf8e9f01816653a3b2d2f4fc7bfe1dab956f00db5c7e7689e5f1454029a\nStatus: Downloaded newer image for wordpress:latest\nWordPress not found in /var/www/html - copying now...\nComplete! WordPress has been successfully copied to /var/www/html\nAH00558: apache2: Could not reliably determine the server's fully qualified domain name,     using 10.17.0.1. Set the 'ServerName' directive globally to suppress this message\nAH00558: apache2: Could not reliably determine the server's fully qualified domain name,     using 10.17.0.1. Set the 'ServerName' directive globally to suppress this message\n[DDD mmm dd hh:mm:ss.iiiiii yyyy] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.25     (Debian) PHP/7.2.10 configured -- resuming normal operations\n[DDD mmm dd hh:mm:ss.iiiiii yyyy] [core:notice] [pid 1] AH00094: Command line: 'apache2     -D FOREGROUND'\n</code></pre> <p>Vemos en la l\u00ednea nueva un nuevo par\u00e1metro: <code>-p 8080:80</code>. Por defecto, un contenedor est\u00e1 totalmente aislado. Pero si estamos montando un blog con WordPress vamos a necesitar acceder a \u00e9l desde el navegador.</p> <p>Con el par\u00e1metro <code>-p</code>, versi\u00f3n corta de <code>--publish</code>, podemos indicar que estamos enlazando un puerto de la m\u00e1quina anfitri\u00f3n con el contenedor. En este caso estamos enlazando el puerto 8080 de la m\u00e1quina anfitri\u00f3n con el 80 del contenedor.</p> <p>Info</p> <p>No vamos a explicar todas las opciones posibles, el tutorial ser\u00eda demasiado largo. Puedes consultar la p\u00e1gina del manual con <code>man docker-run</code> o llamando a la ayuda desde el cliente con <code>docker run --help</code>.</p> <p>En este caso, el formato de <code>publish</code> es:</p> <pre><code>-p, --publish ip:[hostPort]:containerPort | [hostPort:]containerPort\n    Publish a container's port, or range of ports, to the host.\n\nBoth hostPort and containerPort can be specified as a range.  When specifying ranges for both, the number of ports in ranges should be equal.\n\nExamples: -p 1234-1236:1222-1224, -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT.\n\nUse docker port(1) to see the actual mapping, e.g. docker port CONTAINER $CONTAINERPORT.\n</code></pre> <p>Vamos a abrir la siguiente p\u00e1gina web en nuestro navegador:</p> <p>http://localhost:8080</p> <p>La cual nos mostrar\u00e1 el asistente de instalaci\u00f3n de WordPress, el cual no vamos a instalar porque necesitamos una base de datos que a\u00fan no tenemos.</p> <p></p> <p>En su lugar vamos a la consola e interrumpimos la ejecuci\u00f3n del contenedor con Ctrl+C:</p> <pre><code>^C[DDD mmm dd hh:mm:ss.iiiiii yyyy] [mpm_prefork:notice] [pid 1] AH00169: caught SIGTERM, shutting down\n</code></pre>"},{"location":"images/#gestion-de-imagenes","title":"Gesti\u00f3n de im\u00e1genes","text":""},{"location":"images/#descarga","title":"Descarga","text":"<p>Las imagenes que nos descargamos se identifican, adem\u00e1s de por el nombre, por una versi\u00f3n. De esa manera podemos tener distintas versiones de una misma imagen. En la p\u00e1gina del registro de WordPress veremos una pesta\u00f1a con el nombre Tags, con las versiones disponibles.</p> <p>Para usar una en concreto se usa dos puntos seguido del nombre de la versi\u00f3n. Si no se indica nada, como hasta ahora, por defecto se descarga la etiquetada como latest.</p> <p>Podemos descargar im\u00e1genes con la orden <code>docker pull</code>:</p> <pre><code>$ docker pull wordpress:6\nlatest: Pulling from library/wordpress\nDigest: sha256:7121cdf8e9f01816653a3b2d2f4fc7bfe1dab956f00db5c7e7689e5f1454029a\nStatus: Image is up to date for wordpress:latest\n\n$\u00a0docker pull wordpress:php7.1\nphp7.1: Pulling from library/wordpress\n802b00ed6f79: Already exists \n59f5a5a895f8: Already exists \n6898b2dbcfeb: Already exists \n8e0903aaa47e: Already exists \n2961af1e196a: Already exists \n71f7016f79a0: Already exists \n5e1a48e5719c: Already exists \n7ae5291984f3: Already exists \n725b65166f31: Already exists \na2d738459b49: Pull complete \n24830994a3eb: Pull complete \nb3807dc98c17: Pull complete \n59365c2968b5: Pull complete \n36bea53859bb: Pull complete \na777908b01b4: Pull complete \nbd3efa4fff20: Pull complete \n662f2add84f7: Pull complete \n4340a5e4d9f8: Pull complete \n2dbeaf456768: Pull complete \nDigest: sha256:2cc529d3d4ac538f8565d18a893bd1308d6f5522422f4696d87267695f69702c\nStatus: Downloaded newer image for wordpress:php7.1\n</code></pre> <p>En el primer caso no hay descarga porque esa versi\u00f3n ya estaba descargada, en la segunda nos descargamos la versi\u00f3n de la imagen que usa php7.1 en vez de php7.2</p>"},{"location":"images/#listado","title":"Listado","text":"<p>Para ver el listado de images disponibles usamos <code>docker images</code>:</p> <pre><code>$\u00a0docker images\nREPOSITORY   TAG     IMAGE ID      CREATED      SIZE\nwordpress    latest  ca0fefec932b  7 days ago   409MB\nwordpress    php7.1  37664bd9863e  7 days ago   400MB\nhello-world  latest  4ab4c602aa5e  2 weeks ago  1.84kB\n</code></pre>"},{"location":"images/#borrado","title":"Borrado","text":"<p>Si queremos dejar de usar alguna imagen usaremos <code>docker rmi</code>:</p> <pre><code>$\u00a0docker rmi wordpress:php7.1 \nUntagged: wordpress:php7.1\nUntagged: wordpress@sha256:2cc529d3d4ac538f8565d18a893bd1308d6f5522422f4696d87267695f69702c\nDeleted: sha256:37664bd9863efe67a83cb2ff293f1816a9b5f918668ae19ca36b2af3d3b9f62d\nDeleted: sha256:77c97f008777c89455c8e5f248a626b192b62cf07ed1993c9acdfab73be210ee\nDeleted: sha256:14f58345b0bb2efaede03f9424412dce141ea275343305a79952c9c8bda3d1ba\nDeleted: sha256:5902e2becea5be6d672e8a6a84cc66a2f3b8e1b209302a9995de2b9afac8535f\nDeleted: sha256:a5b592bce0a767eed15cce29e5e4a941341a0b8de1633ab8836079c03af31b9e\nDeleted: sha256:6cc2318a4f6975aa87358d9f2852d8b91b335515a1d42ef141af368ee0b6fc05\nDeleted: sha256:c3c8b98ead26315e76cd9625fd59f67cab81afa7810b84a229f4e612097a3db4\nDeleted: sha256:a641d6d5a4f43b035946f9a82c9f126189e8502567bb17c41d25e922a5b314a3\nDeleted: sha256:a7338078acb6f6e8b1a152dabd6e7e47b3e530e1f2e2169b8b69127c9578f8fe\nDeleted: sha256:8f416a21cdea7d5b42d6b799ab4ade2dffe1f6a3b9d83dd02be47a82699922de\nDeleted: sha256:53862f425fbc706f70bd1238a0e929bf6d648547481acfad4910c4c1bde39b95\n</code></pre> <p>Warning</p> <p>Si una imagen est\u00e1 en uso por alg\u00fan contenedor, no nos dejar\u00e1 eliminarla.</p> <pre><code>$\u00a0docker rmi hello-world:latest\nError response from daemon: conflict: unable to remove repository reference \"hello-world:latest\" (must force) - container 5ae8bbb8768d is using its referenced image 4ab4c602aa5e\n</code></pre>"},{"location":"installation/","title":"Instalaci\u00f3n","text":"<p>Existe dos versiones de Docker, una libre y otra que no lo es. Nos ocuparemos exclusivamente de la primera: Docker CE (Community Edition).</p>"},{"location":"installation/#disponibilidad","title":"Disponibilidad","text":"<p>Docker CE est\u00e1 disponible para los siguientes sistemas GNU/Linux: CentOS, Debian, Fedora y Ubuntu. No todas est\u00e1n en m\u00faltiples arquitecturas, pero s\u00ed todas soportan x86_64/amd64. Si tienes otra arquitectura u otro sistema es mejor que uses una m\u00e1quina virtual para arrancar una distribuci\u00f3n compatible.</p> <p>Para m\u00e1s informaci\u00f3n sobre sistemas privativos soportados, leer la secci\u00f3n de plataformas soportadas de la documentaci\u00f3n oficial.</p>"},{"location":"installation/#instalacion_1","title":"Instalaci\u00f3n","text":"<p>Debido a que, dependiendo de la distribuci\u00f3n, la forma de instalarlo difiere, es mejor consultar la documentaci\u00f3n oficial para saber como instalar Docker en tu m\u00e1quina.</p> <ul> <li>Ubuntu: https://docs.docker.com/install/linux/docker-ce/ubuntu/</li> <li>Debian: https://docs.docker.com/install/linux/docker-ce/debian/</li> <li>CentOS: https://docs.docker.com/install/linux/docker-ce/centos/</li> <li>Fedora: https://docs.docker.com/install/linux/docker-ce/fedora/</li> </ul> <p>Warning</p> <p>Este taller se basa en Docker Engine. Docker tambi\u00e9n ofrece Docker Desktop para Linux, adem\u00e1s de para otros sistemas privativos. Docker Desktop no es software libre y por tanto no recomendamos su uso. Especialmente en Linux, puesto que lo que hace es crear una m\u00e1quina virtual reduciendo el uso de memoria y recursos.</p> <p>Si quieres instalar y probar Linux por primera vez, te recomendamos que uses una versi\u00f3n LTS de Ubuntu, por ser f\u00e1cil de instalar y tener un ciclo de mantenimiento de seguridad ampliado. Obviamente necesitas tener conexi\u00f3n a Internet para instalar y probar Docker.</p> <p>Para saber si tienes Docker bien instalado, los tutoriales oficiales siempre te indican inicies un contenedor de ejemplo. Esto es lo que sucede:</p> <p>Example</p> <p>Los c\u00f3digos de ejemplo ir\u00e1n acompa\u00f1ados de una caja como esta para poder copiar y pegar los comandos.</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>El resultado es el siguiente:</p> <pre><code>$ sudo docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\nd1725b59e92d: Pull complete \nDigest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n    1. The Docker client contacted the Docker daemon.\n    2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n    3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n    4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n    $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n    https://hub.docker.com/\n\nFor more examples and ideas, visit:\n    https://docs.docker.com/get-started/\n</code></pre> <p>En la l\u00ednea 1 estamos ejecutando el cliente de Docker, y estamos indicando que queremos ejecutar un contenedor a partir de la imagen hello-world del registro p\u00fablico de Docker.</p> <p>Si es la primera vez que hemos ejecutado esa imagen, nos aparecer\u00e1 la l\u00ednea 2, que indica que la imagen no puede ser encontrada y va a proceder a buscarla, por defecto, en el registro p\u00fablico. Si tenemos conexi\u00f3n a Internet se descargar\u00e1 la imagen  (l\u00ednea 6) y autom\u00e1ticamente crear\u00e1 un contenedor.</p> <p>Tanto si se ha descargado la imagen o ya estaba descargada, el contenedor se ejecutar\u00e1, obteniendo el texto de bienvenida que se ve en el cuadro anterior.</p>"},{"location":"installation/#configuracion-del-usuario","title":"Configuraci\u00f3n del usuario","text":"<p>Si estamos usando Docker en nuestro ordenador personal, podemos configurar nuestro usuario para usar el cliente sin tener que poner sudo delante. Para ello ejecuta lo siguiente:</p> <p>Example</p> <p>A\u00f1ade tu usuario al grupo de docker.</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>Para que los nuevos permisos surtan efecto, debes cerrar y volver a abrir la sesi\u00f3n</p> <p>Example</p> <p>Por defecto tu usuario no adquiere los nuevos grupos, por eso es necesario reiniciar sesi\u00f3n. Tambi\u00e9n puedes ejecutar la siguiente orden en cada consola, hasta que reinicies sesi\u00f3n:</p> <pre><code>newgrp docker\n</code></pre> <p>Para problemas relacionados con los permisos visitad la p\u00e1gina del manual oficial.</p> <p>Warning</p> <p>Si decides no a\u00f1adir el grupo <code>docker</code> a tu usuario, tendr\u00e1s que ejecutar  <code>docker</code> siempre con sudo. En los ejemplos lo encontrar\u00e1s sin \u00e9l.</p>"},{"location":"installation/#requisitos-del-curso","title":"Requisitos del curso","text":""},{"location":"installation/#imagenes","title":"Im\u00e1genes","text":"<p>Es necesario traer ya instaladas ciertas im\u00e1genes de contenedores. Ejecuta los siguientes comandos en tu equipo (si te da error de permisos aseg\u00farate que has hecho el apartado anterior y abierto y cerrado la sesi\u00f3n).</p> <p>Example</p> <p>Instalar WordPress:</p> <pre><code>docker pull wordpress:6\n</code></pre> <p>Example</p> <p>Instalar MariaDB:</p> <pre><code>docker pull mariadb:10\n</code></pre>"},{"location":"introduction/","title":"Introducci\u00f3n","text":"<p>Seg\u00fan la Wikipedia: \"Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales.\"<sup>1</sup>.</p> <p>Esto es una descripci\u00f3n formal, pero para enterarte de qu\u00e9 es docker sigue leyendo:</p>"},{"location":"introduction/#a-quien-le-puede-interesar-usar-docker","title":"\u00bfA qui\u00e9n le puede interesar usar docker?","text":"<p>Docker es \u00fatil a administradores de sistemas, pero tambi\u00e9n a desarrolladores. Uno de los problemas que se presentan durante el desarrollo y despliegue de aplicaciones es encontrarnos con sistemas heterog\u00e9neos, no ya entre los desarrolladores, tambi\u00e9n entre los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n. Es decir, que los desarrolladores y los sistemas donde se ejecuta la aplicaci\u00f3n tienen librer\u00edas y sistemas operativos diferentes. \u00bfY por qu\u00e9 es un problema? Pues porque la aplicaci\u00f3n puede funcionar bien en una distribuci\u00f3n de GNU/Linux pero no bien en otra, o ejecutarse bien con la versi\u00f3n de un lenguaje pero no con otra. Para asegurar la calidad de desarrollo tenemos que asegurar que todo el mundo usa las mismas versiones de todas las aplicaciones y librer\u00edas necesarios.</p> <p>Esto es m\u00e1s complicado de lo que parece, porque hay desarrolladores que prefieron una distribuci\u00f3n concreta, o incluso sistemas privativos. Incluso los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n suelen ser distintos. Los sistemas de producci\u00f3n suelen ser m\u00e1s nuevos y potentes y los antiguos se dejan para pruebas y pre-producci\u00f3n.</p> <p>Otro problema es que un mismo desarrollador o un mismo sistema de despliegue tenga que trabajar en m\u00e1s de un proyecto que requiera versiones distintas de librer\u00edas, complic\u00e1ndolo a\u00fan m\u00e1s.</p> <p>Docker viene a solucionar todos estos problemas, tanto para los desarrolladores como para los administradores de sistemas. Con Docker podemos crear entornos aislados con configuraciones que ser\u00e1n exactamente igual siempre.</p>"},{"location":"introduction/#docker-es-virtualizacion","title":"\u00bfDocker es virtualizaci\u00f3n?","text":"<p>En GNU/Linux Docker no es virtualizado, no hay un hipervisor. Los procesos que corren dentro de un contenedor de docker se ejecutan con el mismo kernel que la m\u00e1quina anfitri\u00f3n. Linux lo que hace es aislar esos procesos del resto de procesos del sistema, ya sean los propios de la m\u00e1quina anfitri\u00f3n o procesos de otros contenedores. Adem\u00e1s, es capaz de controlar los recursos que se le asignan a esos contenedores (cpu, memoria, red, etc.). Internamente, el contenedor no sabe que lo es y a todos los efectos es una distribuci\u00f3n GNU/Linux independiente, pero sin la penalizaci\u00f3n de rendimiento que tienen los sistemas virtualizados.</p> <p>As\u00ed que, cuando ejecutamos un contenedor, estamos ejecutando un servicio dentro de una distribuci\u00f3n construida a partir de una \"receta\". Esa receta permite que el sistema que se ejecuta sea siempre el mismo, independientemente de si estamos usando Docker en Ubuntu, Fedora o, incluso, sistemas privativos compatibles con Docker. De esa manera podemos garantizar que estamos desarrollando o desplegando nuestra aplicaci\u00f3n, siempre con la misma versi\u00f3n de todas las dependencias.</p> <p>Obviamente, si ejecutamos contenedores GNU/Linux dentro de sistemas privativos, s\u00ed habr\u00e1 virtualizaci\u00f3n.</p>"},{"location":"introduction/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":"<p>Antes de comenzar a instalar y usar docker es importante tener una serie de conceptos claros<sup>2</sup>:</p> Demonio de docker (docker daemon) Es el proceso principal de docker. Escucha peticiones a la API y maneja los objetos de docker: im\u00e1genes, contenedores, redes, vol\u00famenes. Tambi\u00e9n es capaz de comunicarse con otros demonios para controlar servicios docker. Cliente de docker (docker client) Es la principal herramienta que usan los administradores de sistema para interaccionar con el sistema Docker. Registro de docker (docker registry) Es el lugar donde se almacenan las im\u00e1genes de Docker y poder descargarlas para reutilizarlas. Docker Hub es el principal registro p\u00fablico de Docker y contiene ya un mont\u00f3n de im\u00e1genes listas para ser usadas de multitud de servicios (mysql, wordpress, etc)."},{"location":"introduction/#objetos-de-docker","title":"Objetos de docker","text":"<p>Cuando usamos Docker, estamos creando y usando im\u00e1genes, contenedores, redes o vol\u00famenes, entre otros. A todo esto se le denominan objetos. Veamos los m\u00e1s importantes:</p> Imagen (image) Plantilla de solo lectura que contiene las instrucciones para crear un contenedor Docker. Pueden estar basadas en otras imagenes, lo cual es habitual. Contenedor (container) Es una instancia ejecutable de una imagen. Esta instancia puede ser creada, iniciada, detenida, movida o eliminada a trav\u00e9s del cliente de Docker o de la API. Las instancias se pueden conectar a una o m\u00e1s redes, sistemas de almacenamiento, o incluso se puede crear una imagen a partir del estado de un contenedor. Se puede controlar c\u00f3mo de aislado est\u00e1 el contenedor del sistema anfitri\u00f3n y del resto de contenedores. El contenedor est\u00e1 definido tanto por la imagen de la que procede como de las opciones de configuraci\u00f3n que permita. Por ejemplo, la imagen oficial de MariaDb permite configurar a trav\u00e9s de opciones la contrase\u00f1a del administrador, de la primera base de datos que se cree, del usuario que la maneja, etc. Servicios (services) Los servicios permiten escalar contenedor a trav\u00e9s de m\u00faltiples demonios de Docker, los cuales trabajar\u00e1n conjuntamente como un enjambre (swarm)."},{"location":"introduction/#objetivos-del-taller","title":"Objetivos del taller","text":"<p>En este taller aprenderemos:</p> <ul> <li>A usar el registro oficial de Docker, a descargar y usar im\u00e1genes del mismo creando contenedores que nos puedan ser \u00fatiles.</li> <li>A crear una imagen a partir de otra.</li> <li>A automatizar la creaci\u00f3n de un conjunto de contenedores que interaccionan entre s\u00ed.</li> </ul> <p>En este taller no aprenderemos:</p> <ul> <li>A crear un cluster con Docker (Docker Swarm).</li> <li>A administrar sistemas. Se dar\u00e1n ya las instrucciones necesarias para crear servicios pero explicarlos est\u00e1 m\u00e1s alla del \u00e1mbito de este taller. Se recomienda cursar la asignatura: \"Programaci\u00f3n y Administraci\u00f3n de Sistemas\" del Grado de Ingenier\u00eda Inform\u00e1tica.</li> </ul> <ol> <li> <p>Wikipedia: https://es.wikipedia.org/wiki/Docker_(software) \u21a9</p> </li> <li> <p>Official Docker Documentation: Docker overview.\u00a0\u21a9</p> </li> </ol>"},{"location":"tips/","title":"Trucos","text":""},{"location":"tips/#portainer","title":"Portainer","text":"<p>Portainer es una gestor de contenedores a trav\u00e9s de una interfaz web. Para usarlo creamos un directorio donde guardar nuestro docker-compose.yaml.</p> <pre><code>mkdir -p ~/Sites/portainer\ncd ~/Sites/portainer\n</code></pre> <p>Guardamos el siguiente fichero como docker-compose.yaml en nuestro directorio:</p> docker-compose.yaml<pre><code>services:\n    portainer:\n    image: portainer/portainer\n    command: -H unix:///var/run/docker.sock\n    volumes:\n        - /var/run/docker.sock:/var/run/docker.sock\n        - portainer_data:/data\n    ports:\n        - 127.0.0.1:9000:9000\nvolumes:\n    portainer_data:\n</code></pre> <p>Y ejecutamos el contenedor:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"tips/#limpieza","title":"Limpieza","text":"<p>Para borrar objetos que no est\u00e1n en uso:</p> <pre><code>docker system prune\n</code></pre> <p>Para borrar vol\u00famenes que no est\u00e1n asociados a ning\u00fan contenedor:</p> <pre><code>docker volume rm $(docker volume ls -q -f \"dangling=true\")\n</code></pre> <p>Para borrar contenedores que han terminado su ejecuci\u00f3n:</p> <pre><code>docker rm $(docker ps -q -f \"status=exited\")\n</code></pre> <p>Para borrar im\u00e1genes que no est\u00e1n etiquetadas:</p> <pre><code>docker rmi $(docker images -q -f \"dangling=true\")\n</code></pre>"},{"location":"tips/#copias-de-seguridad","title":"Copias de seguridad","text":"<p>Para hacer una copia de seguridad:</p> <pre><code>docker run --rm -v /tmp:/backup \\\n    --volumes-from &lt;container-name&gt; \\\n    busybox tar -cvf /backup/backup.tar &lt;path-to-data&gt;\n</code></pre> <p>Para restaurar:</p> <pre><code>docker run --rm -v /tmp:/backup \\\n    --volumes-from &lt;container-name&gt; \n    busybox tar -xvf /backup/backup.tar &lt;path-to-data&gt;\n</code></pre>"},{"location":"tips/#fuentes-de-esta-pagina","title":"Fuentes de esta p\u00e1gina:","text":"<ol> <li>https://codefresh.io/docker-tutorial/everyday-hacks-docker/</li> <li>http://blog.labianchin.me/2016/02/15/docker-tips-and-tricks</li> </ol>"},{"location":"tips/#imagenes-base","title":"Im\u00e1genes base","text":"<p>Son las im\u00e1genes m\u00e1s conocidas por las que podemos usar para no partir desde cero para crear la nuestra.</p> <ul> <li>phusion/baseimage: 209mb</li> <li>centos: 200mb</li> <li>debian: 101mb</li> <li>ubuntu: 84mb</li> <li>alpine: 4.4mb</li> <li>busybox: 1.16mb</li> </ul>"},{"location":"wordpress/","title":"Levantar un WordPress con Docker","text":"<p>Para crear un blog con WordPress necesitamos tener una base de datos d\u00f3nde almacenar las entradas. As\u00ed que empezaremos cre\u00e1ndola y despu\u00e9s crearemos el contenedor de nuestro blog.</p>"},{"location":"wordpress/#crear-un-contenedor-con-mariadb","title":"Crear un contenedor con MariaDB.","text":"<p>WordPress soporta los motores relaciones MySQL y MariaDB. Usaremos este \u00faltimo.</p> <p>Example</p> <p>Vamos a crear nuestra base de datos usando este volumen.</p> <pre><code>docker run -d --name wordpress-db \\\n    --mount source=wordpress-db,target=/var/lib/mysql \\\n    -e MYSQL_ROOT_PASSWORD=secret \\\n    -e MYSQL_DATABASE=wordpress \\\n    -e MYSQL_USER=manager \\\n    -e MYSQL_PASSWORD=secret mariadb:10\n</code></pre> <p>La imagen se descargar\u00e1, si no lo estaba ya, y se iniciar\u00e1 nuestro contenedor de MariaDB:</p> <pre><code>$ docker run -d --name wordpress-db \\\n    --mount source=wordpress-db,target=/var/lib/mysql \\\n    -e MYSQL_ROOT_PASSWORD=secret \\\n    -e MYSQL_DATABASE=wordpress \\\n    -e MYSQL_USER=manager \\\n    -e MYSQL_PASSWORD=secret mariadb:10\nUnable to find image 'mariadb:10' locally\n10: Pulling from library/mariadb\n124c757242f8: Pull complete \n9d866f8bde2a: Pull complete \nfa3f2f277e67: Pull complete \n398d32b153e8: Pull complete \nafde35469481: Pull complete \n31f2ae82b3e3: Pull complete \n3eeaf7e45ea6: Pull complete \n716982328e17: Pull complete \n34ce605c9036: Pull complete \n4502ed9073c0: Pull complete \n2afafbdf5a96: Pull complete \n43d52b11dd31: Pull complete \n30c7b70556f3: Pull complete \n8b1b39f2f89a: Pull complete \n41480b9319d7: Pull complete \nDigest: sha256:b7894bd08e5752acdd41fea654cb89467c99e67b8293975bb5d787b27e66ce1a\nStatus: Downloaded newer image for mariadb:10\n30634831d17108aa553a5774e27f398760bdbdf32debc3179843e73aa5957956\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\n30634831d171        mariadb:10      \"docker-entrypoint.s\u2026\"   20 seconds ago      Up 16 seconds       3306/tcp            wordpress-db\n</code></pre> <p>El principal cambio en <code>docker run</code> con respecto a la \u00faltima vez es que no hemos usado <code>-p</code> (el par\u00e1metro para publicar puertos) y hemos a\u00f1adido el par\u00e1metro <code>-d</code>.</p> <p>Lo primero que habremos notado es que el contenedor ya no se queda en primer plano. El par\u00e1metro <code>-d</code> indica que debe ejecutarse como un proceso en segundo plano. As\u00ed no podremos pararlo por accidente con Ctrl+C.</p> <p>Lo segundo es que vemos que el contenedor usa un puerto, el <code>3306/tcp</code>, pero no est\u00e1 linkado a la m\u00e1quina anfitri\u00f3n. No tenemos forma de acceder a la base de datos directamente. Nuestra intenci\u00f3n es que solo el contenedor de WordPress pueda acceder.</p> <p>Luego una serie de par\u00e1metros <code>-e</code> que nos permite configurar nuestra base de datos.</p> <p>Info</p> <p>Los contenedores se configuran a trav\u00e9s de variables de ambiente, que podemos configurar con el par\u00e1metro <code>-e</code> que vemos en la orden anterior. Gracias a ellos hemos creado una base de datos, un usuario y configurado las contrase\u00f1as.</p> <p>Se recomienda buscar en el registro de Docker la imagen oficial de MariaDB para entender el uso de los par\u00e1metros.</p> <p>Por \u00faltimo, el par\u00e1metro <code>--mount</code> nos permite enlazar el volumen que creamos en el paso anterior con el directorio <code>/var/lib/mysql</code> del contenedor. Ese directorio es donde se guardan los datos de MariaDB. Eso significa que si borramos el contenedor, o actualizamos el contenedor a una nueva versi\u00f3n, no perderemos los datos porque ya no se encuentran en \u00e9l, si no en el volumen. Solo lo perder\u00edamos si borramos expl\u00edcitamente el volumen.</p> <p>Warning</p> <p>Cada contendor que usemos tendr\u00e1 uno o varios directorios donde se deben guardar los datos no vol\u00e1tiles. Nos corresponde a nosotros conocer la herramienta y saber de qu\u00e9 directorios se tratan. Usualmente est\u00e1n en la documentaci\u00f3n del contenedor, pero no siempre.</p> <p>Info</p> <p>El par\u00e1metro <code>--mount</code> se empez\u00f3 a utilizar desde la versi\u00f3n <code>17.06</code> para contenedores independientes (los que no pertenecen a un enjambre o swarm). Los que conozcan Docker de versiones m\u00e1s antiguas estar\u00e1n m\u00e1s acostumbrados a usar el par\u00e1metro <code>--volume</code> que hace algo similar. Sin embargo la documentaci\u00f3n aconseja usar ya <code>--mount</code>, sobre todo para nuevos usuarios.</p> <p>Nosotros somos muy obedientes as\u00ed que en este taller usaremos <code>--mount</code>.</p>"},{"location":"wordpress/#creando-nuestro-blog","title":"Creando nuestro blog","text":"<p>Vamos a crear otra vez nuestro contenedor de WordPress, pero esta vez vamos a conectarlo con nuestra base de datos. Adem\u00e1s, queremos poder editar los ficheros de las plantillas, por si tenemos que modificar algo, as\u00ed que necesitaremos montar el directorio del contenedor donde est\u00e1 instalado WordPress con nuestra cuenta de usuario en la m\u00e1quina anfitri\u00f3n.</p> <p>Example</p> <p>Vamos a crear el espacio de trabajo:</p> <pre><code>mkdir -p ~/Sites/wordpress/target &amp;&amp; cd ~/Sites/wordpress\n</code></pre> <p>Example</p> <p>Y dentro de este directorio arrancamos el contenedor:</p> <pre><code>docker run -d --name wordpress \\\n    --link wordpress-db:mysql \\\n    --mount type=bind,source=\"$(pwd)\"/target,target=/var/www/html \\\n    -e WORDPRESS_DB_USER=manager \\\n    -e WORDPRESS_DB_PASSWORD=secret \\\n    -p 8080:80 \\\n    wordpress:6\n</code></pre> <p>Cuando termine la ejecuci\u00f3n, si accedemos a la direcci\u00f3n http://localhost:8080/, ahora s\u00ed podremos acabar el proceso de instalaci\u00f3n de nuestro WordPress. Si listamos el directorio target comprobaremos que tenemos todos los archivos de instalaci\u00f3n accesibles desde el directorio anfitri\u00f3n.</p> <p>Note</p> <p>Ejercicios:</p> <ol> <li>Para los contenedores, tanto el de WordPress como el MariaDB.</li> <li>Borra ambos.</li> <li>Vuelve a crearlos y mira como ya no es necesario volver a instalar WordPress.</li> <li>Vuelve a borrarlos y borra tambi\u00e9n el volumen.</li> <li>Vuelve a crear el volumen y los contenedores y comprueba que ahora s\u00ed hay que volver a instalar WordPress.</li> </ol>"}]}